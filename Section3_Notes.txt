# Section 3: Database

## 23) Creating the Database:

The only remaining major component we're missing now to cover the essence of a web app is the database, which is used to persist data over time.
This is important because if someone comes to your web app and does something then when they come a month later, you want 
whatever they did to still be there as that becomes part of a good user experience, if that forms part of your app design.
The databse is the only really external part in the flask tutorials we'll be doing, will need both sqlite3 installed for both 
python and system.
On windows, it comes pre-installed with python, however it'll need to be installed for the system, and the easiest way
to do this is to run the command prompt as admin, and the run the following command:
    "winget install sqlite.sqlite"
Accept the terms of use, them restart the code editor once the install is completed.
The first thing we'll need to do is create the sqlite database, to do this, we'll run the following command:
    "sqlite3 data.db"
where 'data.db' is the database name.
Next we'll create a table called 'users' as almost every web app will have this table and some basic columns:
    "create table users (id integer primary key autoincrement, name text, location text);"
Then once this has run, we can run the command ".tables" to verify that the table was created successfully.
Now if we insert data into the table, we should be able to see it when we do a query.
As is, if we ran:
    "select * from users;"
We'd get no response as the table is still empty.
So we'll insert some data into the table:
    "insert into users (name, location) values ('Anthony', 'Texas');"
So once the data is in, we'll see data when we run the select again.

## 24) Connect to the Database:

Note that when testing the db in the terminal, we go into sqlite3 command line, and to exit this, simply pass the command:
    ".quit"
Having created the database, we need to now connect to it in flask and use it.
The first thing to do being to "import sqlite3"
We'll also need to import a global object named 'g' from flask:
    "from flask import g"
g is a global object from flask that allows you to store data on it, similar to sessions.
It's where all the parts of your application will use it as your app is running.
Now we want to create a function that'll connect to the database, so that whenever we need access to the database, we can call 
this function.
We'll add it under our app.configs and call it "connect_db"
Then inside it we'll call the connect function from sqlite3 library and assign it a namespace.
    "sql = sqlite3.connect('./data.db')"
Where ./data.db is the path to the database, though in future it may be a better idea to pass the entire filebath, especially for server-side programming.
By default, when you run a query in sqlite3 you'll get a list of tuples and tuples are somewhat harder to work with than Python dictionaries.
So we'll call sqlite3.Row and add it to the row_factory to have get python dictionaries instead of tuples.
    "sql.row_factory = sqlite3.Row"
And then lastly we'll return the 'sql' object.
Now we'll create another function that'll get the database called 'get_db'
So in general, we first need to connect to the database and then get it in order to be able to work with it.
First we'll check if the database is already there as it does sometime get used more than once.
If it's not there, we call the connect_db function to be able to get it.
This is also where the g object comes in, as we house the db connection within the g object.
    "g.sqlite_db = connect_db()"
And this is why we have the attribute check to see if the db connection is already in g as we need to have it stored somewhere
in order for us to be able to use it.
Finally, good practice is to close the connection to the database after every route finishes running, and instead of doing it 
manually every time, we can do it automatically when the route returns.
Now above all our routes, we'll add a decorator "app.teardown_appcontext" which is automatically called whenever a route returns.
For the teardown we'll create a function called "close_db" and pass it an 'error' parameter that is passed to it automatically.
Now in this function all we're doing is checking if the global object g has a sqlite database, then we close the sqlite database.
This is done to prevent memory leaks because if you leave the database connection open and the route retur.
Then no one else would be able to access the database as the open connection would remain but be lost in memory and inaccessible.

## 25) Queries:

